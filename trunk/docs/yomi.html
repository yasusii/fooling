<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=euc-jp">
<title>
視覚障害者のための読みがなによる全文検索システム、その提案と実装
</title>
<style type="text/css">
BODY { line-height: 130%; }
BLOCKQUOTE { background: #eeeeee; }
CODE { background: #eeeeee; }
KBD { background: #eeeeee; font-weight: bold; }
</style>
</head>
<body>
<h2>
視覚障害者のための読みがなによる全文検索システム、その提案と実装
</h2>

<h3>概要</h3>
<p>
本稿では視覚障害者の利用を想定した、
漢字をふくむ日本語文字列を読みがなだけで検索するシステムを提案する。
本手法は bi-gram と動的計画法をもちいて、漢字を含む文字列を
すべての可能な読み方で効率的にインデックス、および検索することを可能にする。
なお、本手法は数十万文書程度の大規模な文書検索にも応用可能である。


<h3>背景</h3>
<p>
現在の視覚障害者は、おもに点字ディスプレイまたは
音声合成をもちいた画面読み上げソフトウェア (スクリーンリーダ) を用いて
コンピュータにアクセスしている。しかし現在普及している点字は
ほとんどが表音文字であり (注: 点字をもちいて漢字を表現する 
6点漢字あるいは 8点漢字という手法も提案されているが、
まだ広く普及するには至っていない)、
画面読み上げソフトウェアもまた音声に頼っていることから、
視覚障害者が日本語の漢字表記に触れる機会は晴眼者に比べて少ない。
このことは、コンピュータを使って大規模な文書検索をおこなうさいに
問題となる。現在普及している、文字列一致による検索システムでは
ユーザは検索したい単語がどのような綴りなのか、あるいはそもそもそれが漢字
(あるいはカタカナ) によって表現されているのかどうかを
あらかじめ知っている必要がある。
さらに複数の単語からなる文や句全体を検索する際には、
ユーザはそれが (一般的な かな漢字変換ソフトウェアを用いて) どのように
漢字に変換されるかもある程度予測できていなければならない。
このようなことは、漢字表記を普段からあまり意識していない
視覚障害のユーザーにとって困難である。そこで、
この記事では漢字 (あるいはカタカナ) を含む文字列の「読み」だけで
大規模な文書集合を効率よく検索できるような機構を提案する。
<p>
検索システムを設計する立場から考えると、この問題は検索対象となる
文字列に含まれる漢字すべてに正しい読み方を付与すれば解決できるように思われる。
しかし、すべての漢字、とりわけ日本語の固有名詞に対して
一意の読み方を付与することは難しい。固有名詞は同じ漢字表記であっても
さまざまな読み方が存在し、適切な文脈情報なしには読みを決定することは
不可能である。たとえば「<code>新山</code>」という文字列には、
「<code>にいやま</code>」「<code>しんやま</code>」「<code>しんざん</code>」などの可能な読み方が存在する。
また、たとえ正しい読みが付与できたとしても、ユーザがその読み方を
知らないこともありうる。なぜなら一般的な音声合成技術を使っている
現在のスクリーンリーダは、まさに上で示した理由により、固有名詞を正しく
発音しない場合が多いからである。
そこで本記事で提案する検索システムでは、ある漢字かな混じり文字列を
可能なすべての読みで検索できるようにすることを目標とする。
しかし、伝統的な手法を用いてこのような検索を実現しようとすると
計算量およびデータ量の増大という問題が発生する。
たとえば「<code>日本の祭事</code>」という文字列を考えてみよう。
「日本」という文字列は「にほん」とも「にっぽん」とも読めるし、
また「祭事」は、「さいじ」あるいは「まつりごと」とも読めるので、
少なくとも「日本の祭事」に対しては「にほんのさいじ」「にっぽんのさいじ」
「にほんのまつりごと」「にっぽんのまつりごと」の 4種類の読み方が存在する。
このような読み方をすべて列挙すると、一般的に可能性のある読み方は
連続する漢字の数に応じて指数的に増えてしまう。
<P>
本記事では、2-グラム (bi-gram) と動的計画法 (dynamic programming) を
もちいて、これらの可能な読みをすべて現実的な計算時間で処理する
手法を提案する。また、この機構を既存のオープンソース
検索システムである Fooling に実装し、簡単な性能評価をおこなった。
本手法は、文書をすべてひらがな (あるいはカタカナ) による
読みで検索するが、オプションとしてローマ字入力による検索も可能である。
したがって、この手法は将来的に文字入力のためのキーが限られている
携帯デバイスなどからの文書検索システムにも有用であるかもしれない。

<h3>基本的な機構</h3>
<p>
本システムでは、文字列の検索は 2つの段階に分けられる。
ひとつは、検索の絞りこみのためのデータ構造 (インデックス、index) を
検索対象となる文書集合からあらかじめ作成しておく「インデクシング」であり、
もうひとつは実際に与えられた検索要求 (読みがな) に
適合する文書を抽出する「検索処理」である。後述するように、
本システムでは検索処理はさらに 2つの段階
(「絞りこみ」と「逐次検索」) に分けられる。
<p>
一般的な文書検索システムにおいては、インデックスは
ユーザが入力する各検索語をふくんだ文書集合を対応づける写像に
なっている。インデックスは、すべての可能な検索キーワードに対して、
それらが含まれる文書の集合を対応づけるような写像であるが、
返される文書が必ずしもすべて検索結果に完全に一致する必要はない。
インデックスは検索要求に一致する可能性が (他の文書に比べて) 
十分に高いようなものを、適当な数にまで絞りこむために使われる。
本システムはこのアイデアにもとづき、インデックスのキーとして
読みがなの bi-gram を使う。読みがなの bi-gram とは、日本語の
読みがなのうち連続する 2文字をそれぞれ取り出したものである。
たとえば「<code>明後日</code>」という文字列に対応する読みがなは、
「あさって」であるが、これは
「<code>あさ</code>」「<code>さっ</code>」「<code>って</code>」という 3つの bi-gram に分解できる。
本システムでは、このような読みがなの対応は辞書ファイルによって与えられる。
なお、実際には本システムではインデックスする単位は文書ではなく、各文書中の
文である。システムはインデックスする文書を個々の文に分解し、
これらの文から bi-gram を取得してインデックスする。
したがって、実際のインデックスには、
「<code>あさ</code>」が含まれるすべての文、
「<code>さっ</code>」が含まれるすべての文、
そして「<code>って</code>」が含まれるすべての文が、
それぞれの bi-gram に対応づけられて格納されている
(注: 実際に格納されているのは文章の文字列そのものではなく、
各文章への参照である)。


<h4>検索の流れ</h4>
<p>
例として、「あさっては」という読みが含まれる文:
<center>
「<code>明後日は試合だ。</code>」
</center>
<p>
を検索することを考えてみよう。
システムはまずこの文を読みがなの bi-gram 列に分解し、
インデックスしておく。とりあえず、システムは
<p>
<center>
「<code>明後日</code>」→「<code>あさって</code>」、
「<code>試合</code>」→「<code>しあい</code>」
</center>
<p>
のような単語と読みの対応関係を記述した辞書をもっていると仮定する。
この場合、システムは次のような bi-gram 列を得ることになる:
<p>
<center>
「<code>あさ</code>」
「<code>さっ</code>」
「<code>って</code>」
「<code>ては</code>」
「<code>はし</code>」
「<code>しあ</code>」
「<code>あい</code>」
「<code>いだ</code>」
</center>
<p>
システムはこれらの bi-gram からこの文への写像をインデックスに格納する。
このあとユーザが「<code>あさっては</code>」という検索要求 (読みがな) により
検索をおこなったとすると、システムはまずこの検索語を 3つの bi-gram 
「<code>あさ</code>」「<code>さっ</code>」「<code>って</code>」「<code>ては</code>」に
変換する。つぎにインデックスを参照し、
これら 3つの bi-gram すべてが含まれているような文をとりだす。
各 bi-gram <em>x</em> に対応する文の集合を S(<em>x</em>) とすると、
これは以下のような集合演算によって計算できる:
<P>
<center>
S("<code>あさ</code>") ∩ S("<code>さっ</code>") ∩ S("<code>って</code>") ∩ S("<code>ては</code>")
</center>
<p>
しかし、これだけでは検索結果としては十分ではない。
もしインデックスに以下のような文章も登録されていたとすると:
<P>
<center>
「<code>浅間山がさっき煙を吹いたってハロルド君が言ってたよ。</code>」
</center>
<p>
ここにも
「<code>あさ</code>」「<code>さっ</code>」「<code>って</code>」「<code>ては</code>」
という bi-gram が現れるからである。
そのためインデックスから返された文集合に対して、
さらなる絞りこみ処理をおこなう必要がある。
しかし重要なことは、このような文はそれほど多くないということである。
したがってインデックスから得られた文に逐次検索をおこなっても、
それらの中には検索要求に実際に一致する可能性が高いものが多く含まれている。
このように、インデックスを使うことにより、検索対象となる文を
絞りこむことができる。
<p>
(注: ここで読者は、連続した箇所に表われる bi-gram のみを
対象にすればさらに対象となる文が絞りこめると考えるかもしれない。
しかし、実際には「<code>明後日</code>」という単語は
「みょうごにち」とも読めるため、実は
本システムではこれらの読みがなに対応する bi-gram 列
「みょ」「ょう」「うご」「ごに」「にち」もインデックスされている。
これら 2つの読み (「あさって」「みょうごにち」) には特に
優先順位がないので、これらの bi-gram が実際にどのような順序で
現れるべきかをシステムが決定することはむずかしい。
「あさ」「さっ」「って」の部分はたしかに連続した bi-gram 列として
インデックス中に現れるかもしれないが、「ては」の部分は
すこし離れた位置に格納されているかもしれない。
そもそも「<code>明後日は</code>」という文字列のどこに
「あさ」「さっ」「って」という bi-gram が現れるのかを
厳密にいうのはむずかしい。なぜなら「明後日」という熟語は
それ全体をさして「あさって」と読むのであって、「明」「後」「日」の
各読みがぞれぞれ「あさ」「さっ」「って」に分解できる、
というものではないからである。このような理由により、
本システムではインデックスを使った絞りこみの時には bi-gram の
順序を考慮せず、たんなる文字列の集合として扱う。これ以降の
厳密な絞りこみは次で述べる逐次検索によっておこなうものとする。)
<p>
さて、対象となる文を絞りこんだあとは、それらすべてに対して、
本当に検索要求にマッチする文を逐次検索で調べる必要がある。
本システムでは可能なすべての読み方での検索を許しているので、
「<code>明後日</code>」という文字列は「あさって」でも「みょうごにち」でも
検索できるようにしたい。このように複数存在する漢字の読みを、
単一の読みがなに効率よくマッチさせる作業は、本質的には構文解析における
chart parsing と同じである。すなわち、ユーザが入力した読みがなを
終端記号列として、
<ul>
<li> <code>明</code> → みょう
<li> <code>後</code> → ご
<li> <code>日</code> → にち、じつ
<li> <code>明後日</code> → あさって
</ul>
という導出規則から、「<code>明後日</code>」が
「あさって」あるいは「みょうごにち」を
導出できるかどうかを調べればよい。この操作をインデックスによって
絞りこまれた各文に対しておこなえば、検索は完了する。
<p>
以下の節では読みがな検索のためのインデクシングとマッチングを
それぞれ現実的な時間および記憶容量でおこなうためのアルゴリズムを示す。

<h3>インデクシングのアルゴリズム</h3>
<p>
インデクシングとは、インデックスを作成する作業のことである。
本システムでは、ある漢字列があらかじめ用意された
なんらかの辞書によって、可能なすべての読み (ひらがな) に展開できるという
仮定にもとづいている。辞書ファイルにない読みでは検索することができない。
ただし、実際にはすべての読みがなを辞書に入れておく必要はない。
上の例であげた「明」「後」「日」のそれぞれの読み方:
<ul>
<li> <code>明</code> → みょう
<li> <code>後</code> → ご
<li> <code>日</code> → にち、じつ
</ul>
<p>
があれば、「明後日」→「みょうごにち」という読みを登録しておく必要はない。
なぜならシステムは可能なあらゆる読み方を考慮するため、
上の 3つの読み方を知っていれば「明後日」→「みょうごにち」という読みは、
可能な読みとして導出できるからである。同様に「明日 (みょうにち)」
「後日 (ごじつ)」といった読み方も導出できる。
ただし、上の規則からは「明日」を「あした」と読むような読み方は
導出できないため、このような特殊な読みに対しては
個別に辞書に登録しておく必要がある。
このように、本システムで使う読み方の辞書データは
一般のかな漢字変換辞書に比べて大幅に縮小することができるが、
この具体的な方法については後述する。
<p>
さて、具体的なインデクシングの手続きの説明に入る。
文字列「<code>明後日は</code>」が入力されたとき、システムは
これを先頭から読んだときに可能な読み方をすべて辞書ファイルから列挙する。
これは「<code>明</code>」「<code>明後</code>」「<code>明後日</code>」
「<code>明後日は</code>」といった文字列をキーとして辞書を探索し、
読み方が見つかる可能な最大列まで 1文字ずつキーを伸ばしながら探索を続ける。
ここでは
<ul>
<li> 「<code>明</code>」→ みょう
<li> 「<code>明後日</code>」→ あさって
</ul>
という 2つの候補が発見されたとしよう。システムはこれらの読み方を
bi-gram に分解して出力する。つまり「みょ」「ょう」「あさ」「さっ」「って」
の 5種類の bi-gram が出力されるわけである。
<p>
(注: なお、本システムで使っている「読みがな」の単位は、
読みがなを仮名で書き表したときの文字列であり、音韻学でいうところの
「モーラ」ではない。「<code>今日</code>」の読み「きょう」は
実際には 2モーラであるが、本システムでは 3文字の読みとして扱われる)
<P>
つぎにシステムは入力文の 2文字目から同じ処理を開始する。
つまり「<code>後日は</code>」という文字列に対して可能な読みを列挙するのである。
ここでは
<ul>
<li> 「<code>後</code>」→ ご
</ul>
という候補が発見されたとしよう。システムはこの読み方を bi-gram として
出力するのであるが、読み方は前の文字から連続しているため、
ここではひとつ前の文字の読みを含んだ「○ご」という bi-gram を出力しなければ
ならない。ここで ○ の部分に入る文字は何だろうか?
この前の段階で、「明 (みょ<u>う</u>)」という読みが判明しているので、
ここではその最後の文字「う」がそれに該当する。つまりシステムは
「<code>うご</code>」という bi-gram を出力しなければならない。
いっぽう、「明後日 (あさって)」のほうは、まだ文字列の終わりに達していないため、
「あ」「さ」「っ」「て」のどの文字も「<code>ご</code>」のひとつ前の
読みとしては適当でない。したがって、「<code>後</code>」の bi-gram を生成する際には
「明後日 (あさって)」という読みは考えなくてよいことになる。
<P>
つぎに「<code>日</code>」である。システムは以下のような
辞書エントリをもっていると仮定する:
<ul>
<li> 「<code>日</code>」→ にち、じつ
</ul>
システムはここから得られる 2つの bi-gram 「にち」と「じつ」を
それぞれ「<code>日</code>」の読みとして出力するが、
ここでもひとつ前の文字からの読みを含んだ「○に」「○じ」という bi-gram を
出力しなければならない。ひとつ前の文字「後」に対応する読みは
「ご」であるので、「<code>ごに</code>」「<code>ごじ</code>」という bi-gram が
出力される。
<P>
さて、最後の文字「<code>は</code>」に対してはどうだろうか?
これは漢字ではないので、可能な読みは「は」 1通りだけである。
(注: しかし後述するように、本システムでは点字規則を考慮して
これを「わ」としても読めるようにインデックスしているが、
説明を単純にするためここでは無視する。)
したがって、システムは「○は」という形の bi-gram を出力しなければならない。
○ の部分に対応する文字は、「日 (に<u>ち</u> / じ<u>つ</u>)」の読みの最後の文字、
つまり「ち」と「つ」である。さて、以前に取得した「明後日 (あさっ<strong>て</strong>)」の
読みもこの時点で終端に達していることに注意してほしい。
したがって、○ の部分に入るのは「ち」「つ」「て」の3文字ということになる。
すなわちシステムは「<code>ちは</code>」「<code>つは</code>」「<code>ては</code>」の
3つの bi-gram を出力する。
<p>
以上の手続きにおいて、各文字列のつながりを図にしたものが以下の図 1. である。
赤線の流れが「可能な読み方」の bi-gram に該当する。
<p>
<img src="asatte.png"><br>
図1. 「<code>明後日は</code>」から得られる読みがなの bi-gram 
<p>

以上の説明からわかるように、与えられた文字列の読みに対応する bi-gram を
すべて生成するような手続きは、各文字 C<sub><i>i</i></sub> を処理する
段階において、
「現在注目している文字 C<sub><i>i</i></sub> の、
ひとつ前の文字に対応する読み方の、最後の文字」
のみを記憶していればよいということがわかる。
この「各文字に対応する読み方の、最後の文字」の集合を格納しておくバッファを
L<sub><i>i</i></sub> としよう。上の図を使って説明すると、
システムが「<code>明</code>」および「<code>明後日</code>」に対応する
読みを取得した段階で、すでに L<sub>0</sub> には「<code>う</code>」が、
L<sub>2</sub> には「<code>て</code>」が格納できる。
このようにして、各段階でシステムは L 内の文字を蓄積していくが、
実際に各文字 C<sub><i>i</i></sub> を処理するときに使うのは
L<sub><i>i-1</i> だけである。システムはここに格納されている
文字の集合を使って、おのおのの文字 (読みがな) と、現在の文字の読みがなの
先頭の 1文字を使った bi-gram を生成すればよい
(例: <code>う+ご</code>、 <code>ご+に</code>、 <code>ご+じ</code>、etc.)。
<p>
重要なことは、上で示した bi-gram を生成する過程において
文字列の可能な読みの組み合わせが起こるのは、
各文字の境目 (「<code>後</code>」と「<code>日</code>」、
「<code>日</code>」と「<code>は</code>」) だけであって、
これらの局所的な組み合わせはそれ以外の文字に伝播しないということである。
また「明後日 (あさって)」などのひと続きの読みから bi-gram を生成する場合は、
組み合わせを考慮しなければならないのは先頭と最後の文字だけである。
(注: この特徴は bi-gram のかわりに tri-gram を使ったさいにはあてはまらない。)
このようにして、指数的な爆発を抑えつつ可能な読みの bi-gram をすべて
列挙することができる。
<p>
この手続きは以下のように帰納的に定義することができ、したがって
各 L<sub><i>i</i></sub> の値をバッファとした動的計画法の問題として
とらえることができる:
<ol>
<li> ある文字 C<sub><i>i</i></sub> を処理するとき、
C<sub><i>0</i>...<i>i-1</i></sub> までの文字列の bi-gram はすべて
列挙されたと仮定する。
<li> C<sub><i>i</i></sub> から始まる文字列の可能な読み
C<sub><i>i</i>...<i>i+n</i></sub> の bi-gram をすべて列挙するためには、
その部分文字列に対応するすべての読みの (独立した) bi-gram と、
C<sub><i>i-1</i></sub> を含む読みの最後の文字 (つまり
L<sub><i>i-1</i></sub>) がわかっていればよい。
</ol>
<P>
擬似言語を用いた本アルゴリズムの手続きを以下に示す:
<blockquote><pre>
# input: <i>N</i>文字の入力文字列
input = [C<sub>0</sub>, .... C<sub><i>N-1</i></sub>]
# バッファL: <i>N</i>個の空集合
L = [ φ, φ, ... φ ]

for i = 0 ... <i>N-1</i> {
  # 読みがなの集合を辞書から取得
  Y = lookup_yomi(C<sub><i>i</i></sub>, C<sub><i>i+1</i></sub>, ..., C<sub><i>N-1</i></sub>)
  for each y ∈ Y {
    # y は読みがな文字列で、長さ <i>n</i> をもつ
    if 0 &lt; i {
      # ひとつ前の文字から続く bi-gram を出力
      for each c in L<sub><i>i-1</i></sub> {
        emit_bigram(c ・ y<sub>0</sub>)
      }
    }
    for j = 0 ... <i>n-2</i> {
      # bi-gram をひとつ出力
      emit_bigram(y<sub><i>j</i></sub> ・ y<sub><i>j+1</i></sub>)
    }
    # 最後の1文字をバッファに記録
    L<sub><i>i+n-1</i></sub> = L<sub><i>i+n-1</i></sub> ∪ y<sub><i>n-1</i></sub>
  }
}
</pre></blockquote>


<h3>検索のアルゴリズム</h3>
<p>
マッチング部分のアルゴリズムは、構文解析におけるチャートパーザと
本質的に同じである。つまり、与えられた漢字列を終端記号列として、
最終的に元の読みを導出できるか否かを判断する。


<h3>点字規則の追加</h3>
<p>
さて、本システムのユーザが視覚障害者であることを考えると、
ユーザが点字による読みで検索しようとすることも考えられる。

<h3>辞書ファイルの圧縮</h3>


<h3>実験結果</h3>

<h4>実験に用いた文書集合</h4>
<p>
日本語HTML、260ファイル、計8.6MBytes (146,493文、有効文字数:3,659,028)

<h4>インデックスにかかる時間</h4>
<p>
(a) 漢字、ひらがな、カタカナ、英単語のみ: 
インデックス時間: 約7分、インデックスファイルサイズ合計: 39MBytes
<p>
(b) (a)に加えて読みがな:
インデックス時間: 約15分、インデックスファイルサイズ合計: 62MBytes
<p>
漢字bigram: 166,660種類、3,561,494箇所。(1文あたり約24個の bi-gram)
<p>
よみがなbigram: 5,875種類、6,046,784箇所。(1文あたり約41個の bi-gram)

<h4>検索にかかる時間</h4>

<hr noshade>
<address>Yusuke Shinyama</address>
</body>
